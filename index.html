<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador y Chatbot BPMN</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- bpmn-js library -->
    <script src="https://unpkg.com/bpmn-js/dist/bpmn-viewer.development.js"></script>
    <link rel="stylesheet" href="style.css">
</head>

<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen p-6 text-gray-800">

    <div class="container mx-auto p-6 bg-white rounded-lg shadow-xl">
        <h1 class="text-3xl font-bold text-center text-blue-700 mb-8">Visualizador y Chatbot BPMN</h1>

        <!-- BPMN Visualizer Section -->
        <div class="mb-10 p-6 bg-blue-50 rounded-lg shadow-inner">
            <h2 class="text-2xl font-semibold text-blue-600 mb-4">Visualizador de Diagramas BPMN</h2>
            <textarea id="bpmn-xml-input"
                class="w-full h-40 p-3 mb-4 border border-blue-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="Pegue su XML BPMN aquí (ej. el proceso 'Seguimiento de encomiendas internacionales')..."></textarea>
            <button id="load-bpmn-btn"
                class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md shadow-md transition-all duration-300 transform hover:scale-105">
                Cargar Diagrama BPMN
            </button>
            <div id="diagram-viewer" class="diagram-container mt-4"></div>
        </div>

        <!-- Chatbot Section -->
        <div class="p-6 bg-green-50 rounded-lg shadow-inner">
            <h2 class="text-2xl font-semibold text-green-700 mb-4">Chatbot Basado en BPMN</h2>
            <div id="chat-messages" class="chat-messages">
                <!-- Chat messages will appear here -->
            </div>
            <div class="mt-4 flex gap-2">
                <input type="text" id="user-input"
                    class="flex-grow p-3 border border-green-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500 bg-white"
                    placeholder="Escriba su mensaje..." disabled>
                <button id="send-button"
                    class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md shadow-md transition-all duration-300 transform hover:scale-105"
                    disabled>
                    Enviar
                </button>
                <button id="start-chat-btn"
                    class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-md shadow-md transition-all duration-300 transform hover:scale-105">
                    Iniciar Chat
                </button>
            </div>
            <p class="text-sm text-gray-600 mt-2">
                Nota: Este chatbot simula un flujo conversacional basado en el diagrama BPMN cargado.
                Para las tareas, anunciará el paso. Para las compuertas, le pedirá opciones de acuerdo a los nombres de
                los flujos.
            </p>
        </div>
    </div>

    <!-- Custom Modal for Alerts -->
    <div id="custom-modal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" id="close-modal-btn">&times;</span>
            <h3 class="text-xl font-semibold text-gray-800 mb-3" id="modal-title"></h3>
            <p id="modal-message" class="text-gray-700"></p>
        </div>
    </div>

    <script>
        // Función de alerta personalizada para mostrar mensajes al usuario
        function customAlert(title, message) {
            const modal = document.getElementById('custom-modal');
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;
            modal.classList.remove('hidden');
            modal.classList.add('flex'); // Usar flexbox para centrado
        }

        // Cerrar modal cuando se hace clic en el botón de cerrar
        document.getElementById('close-modal-btn').addEventListener('click', () => {
            document.getElementById('custom-modal').classList.add('hidden');
            document.getElementById('custom-modal').classList.remove('flex');
        });

        // Cerrar modal si se hace clic fuera de su contenido
        window.addEventListener('click', (event) => {
            const modal = document.getElementById('custom-modal');
            if (event.target === modal) {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
            }
        });

        // Inicializar el visor BPMN.js
        const BpmnViewer = window.BpmnJS;
        const viewer = new BpmnViewer({
            container: '#diagram-viewer',
            keyboard: {
                bindTo: document
            }
        });

        const bpmnXmlInput = document.getElementById('bpmn-xml-input');
        const loadBpmnBtn = document.getElementById('load-bpmn-btn');

        // Elementos de la interfaz de usuario del chatbot
        const chatMessagesDiv = document.getElementById('chat-messages');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const startChatButton = document.getElementById('start-chat-btn');

        // Variables de estado del chatbot
        let bpmnProcess = null; // Almacena el proceso principal de BPMN
        let elements = {}; // Almacena todos los elementos BPMN (tareas, compuertas, eventos, etc.) por su ID
        let currentElement = null; // El elemento BPMN actualmente activo
        let isChatActive = false;
        let lastHighlightedElementId = null; // Para rastrear el elemento previamente resaltado

        // Función para añadir un mensaje a la interfaz de chat
        function addMessage(sender, text) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            if (sender === 'bot') {
                messageDiv.classList.add('bot-message');
            } else {
                messageDiv.classList.add('user-message');
            }
            messageDiv.textContent = text;
            chatMessagesDiv.appendChild(messageDiv);
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Desplazamiento automático al final
        }

        // Función para resaltar un elemento BPMN en el visor
        function highlightElement(elementId) {
            const canvas = viewer.get('canvas');
            if (lastHighlightedElementId) {
                canvas.removeMarker(lastHighlightedElementId, 'highlight');
            }
            canvas.addMarker(elementId, 'highlight');
            lastHighlightedElementId = elementId;
        }

        // Analizar el XML BPMN para extraer elementos y sus conexiones
        async function parseBPMN(xml) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xml, 'text/xml');
            const bpmnNamespace = 'http://www.omg.org/spec/BPMN/20100524/MODEL';

            // Comprobar errores de análisis de XML
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                console.error('Error de DOMParser:', parseError.textContent);
                customAlert('Error de Análisis BPMN', `Estructura XML inválida detectada: ${parseError.textContent}`);
                return null;
            }

            // Obtener el proceso principal (asumiendo un proceso ejecutable principal para el flujo del chatbot)
            const processes = Array.from(xmlDoc.getElementsByTagNameNS(bpmnNamespace, 'process'));
            // Find the main process, preferably one marked as 'isExecutable'
            let mainProcess = processes.find(p => p.getAttribute('isExecutable') === 'true');
            if (!mainProcess && processes.length > 0) {
                // If no executable process, just take the first one found
                mainProcess = processes[0];
            }

            if (!mainProcess) {
                customAlert('Error de Análisis', 'No se encontró ningún proceso BPMN en el XML.');
                return null;
            }

            const parsedElements = {};
            // Recopilar todos los elementos BPMN relevantes
            const elementTypes = ['startEvent', 'task', 'exclusiveGateway', 'endEvent', 'subProcess', 'intermediateThrowEvent']; // Añadir otros tipos según sea necesario
            elementTypes.forEach(type => {
                Array.from(xmlDoc.getElementsByTagNameNS(bpmnNamespace, type)).forEach(el => { // Convertir a array
                    if (el.id) {
                        parsedElements[el.id] = {
                            id: el.id,
                            name: el.getAttribute('name') || '', // El nombre puede estar vacío para eventos de inicio/fin
                            type: el.localName,
                            outgoing: [],
                            incoming: []
                        };
                    }
                });
            });

            // Rellenar flujos de entrada/salida para flujos de secuencia
            Array.from(xmlDoc.getElementsByTagNameNS(bpmnNamespace, 'sequenceFlow')).forEach(flow => { // Convertir a array
                const sourceRef = flow.getAttribute('sourceRef');
                const targetRef = flow.getAttribute('targetRef');
                const flowName = flow.getAttribute('name') || ''; // El nombre del flujo puede usarse para condiciones

                if (parsedElements[sourceRef]) {
                    parsedElements[sourceRef].outgoing.push({ id: flow.id, target: targetRef, name: flowName });
                }
                if (parsedElements[targetRef]) {
                    parsedElements[targetRef].incoming.push({ id: flow.id, source: sourceRef, name: flowName });
                }
            });

            return { process: mainProcess, elements: parsedElements };
        }

        // Simula el progreso del chatbot a través del diagrama BPMN
        async function proceedChat(userInputText = '') {
            if (!currentElement) {
                customAlert('Error de Chat', 'Proceso de chat no inicializado o completado.');
                endChat();
                return;
            }

            // Resaltar el elemento actual en el diagrama BPMN
            highlightElement(currentElement.id);

            let botMessage = '';
            let nextElementId = null;
            let expectsUserInput = false;
            let choices = []; // Para compuertas

            switch (currentElement.type) {
                case 'startEvent':
                    botMessage = `¡Hola! Soy un chatbot para el seguimiento de encomiendas internacionales. ¿Qué desea realizar?`;
                    // Asumir que el evento de inicio tiene un flujo de salida a la primera tarea
                    nextElementId = currentElement.outgoing[0]?.target;
                    break;

                case 'task':
                case 'subProcess': // Tratar los subprocesos como tareas por ahora
                    botMessage = `Estamos en el paso: "${currentElement.name}".`;

                    // If a task requires user input, handle it here.
                    // This section will need to be made dynamic if task names change often.
                    // For now, it retains the logic for specific task names from the original.
                    if (currentElement.name === 'Qué quiere realizar el usuario?') {
                        botMessage += " Por favor, escriba 'seguimiento' para consultas de seguimiento, 'envio' para consultas de envío, o 'consulta' para una consulta general.";
                        expectsUserInput = true;
                        choices = ['seguimiento', 'envio', 'consulta'];
                    } else if (currentElement.name === 'Solicitud número de seguimiento') {
                        botMessage += " Por favor, proporcione su número de seguimiento.";
                        expectsUserInput = true;
                    } else if (currentElement.name === 'Solicitud Documentación del usuario') {
                        botMessage += " Por favor, confirme si tiene todos los documentos requeridos. Escriba 'sí' o 'no'.";
                        expectsUserInput = true;
                        choices = ['sí', 'no'];
                    } else if (currentElement.name === 'Consulta') {
                        botMessage += " Por favor, describa su consulta general.";
                        expectsUserInput = true;
                    }
                    else {
                        // For other tasks, simply proceed automatically
                        nextElementId = currentElement.outgoing[0]?.target;
                    }
                    break;

                case 'exclusiveGateway':
                    botMessage = `Estamos en una decisión en "${currentElement.name}".`;
                    expectsUserInput = true;
                    // Get options from named outgoing transitions
                    choices = currentElement.outgoing.map(flow => flow.name.toLowerCase()).filter(name => name); 

                    if (choices.length > 0) {
                        botMessage += ` Por favor, elija: ${choices.join(' o ')}.`;
                    } else {
                        // If there are no flow names, offer generic options
                        botMessage += " Por favor, escriba 'sí' o 'no' para continuar.";
                        choices = ['sí', 'no']; 
                    }
                    break;

                case 'intermediateThrowEvent':
                    botMessage = `Ha ocurrido un evento: "${currentElement.name}".`;
                    nextElementId = currentElement.outgoing[0]?.target;
                    break;

                case 'endEvent':
                    botMessage = `El proceso ha concluido: "${currentElement.name}". ¡Gracias por usar el chatbot!`;
                    endChat();
                    return; // End chat immediately after displaying message
            }

            addMessage('bot', botMessage);

            if (expectsUserInput) {
                userInput.disabled = false;
                sendButton.disabled = false;
            } else if (nextElementId) {
                // If no user input is expected, automatically proceed to the next element
                setTimeout(() => {
                    currentElement = elements[nextElementId];
                    proceedChat();
                }, 1000); // Small delay for readability
            } else {
                // No next element found, likely an unhandled end or BPMN error
                addMessage('bot', `Parece que hemos llegado a una parte no manejada del proceso o al final del flujo actual. Por favor, intente iniciar un nuevo chat si tiene más preguntas.`);
                endChat();
            }
        }

        // Función para manejar la entrada del usuario
        async function handleUserInput() {
            const userText = userInput.value.trim();
            if (!userText) return;

            addMessage('user', userText);
            userInput.value = ''; // Clear input field

            userInput.disabled = true;
            sendButton.disabled = true;

            const userLower = userText.toLowerCase();

            // Logic to determine the next step based on the current element and user input
            // This section might still contain some hardcoded task names/IDs from the original diagram.
            // For a truly dynamic chatbot for any BPMN, the interaction logic for tasks and gateways
            // would need to be more generalized or driven by metadata within the BPMN itself.
            if (currentElement.type === 'exclusiveGateway' ||
                currentElement.name === 'Qué quiere realizar el usuario?' ||
                currentElement.name === 'Solicitud Documentación del usuario' ||
                currentElement.name === 'Verificación de la documentación (¿Documentación completa?)' ||
                currentElement.name === '¿Se aprueba el envío?' ||
                currentElement.name === '¿Estado del envío completado?' ||
                currentElement.name === 'Confirmación de identidad') {

                let nextFlow = null;
                const possibleFlows = currentElement.outgoing;

                for (const flow of possibleFlows) {
                    const flowNameLower = flow.name.toLowerCase();

                    // Check if user input matches the flow name (condition)
                    if (userLower.includes(flowNameLower)) {
                        nextFlow = flow;
                        break;
                    }

                    // Specific handling for "sí"/"no" in flows without explicit names or with names like "SI"/"NO"
                    if ((userLower === 'sí' || userLower === 'si') && (flowNameLower === 'si' || flowNameLower === 'sí')) {
                        nextFlow = flow;
                        break;
                    }
                    if (userLower === 'no' && flowNameLower === 'no') {
                        nextFlow = flow;
                        break;
                    }

                    // For "Qué quiere realizar el usuario?", map inputs to specific task names
                    if (currentElement.name === 'Qué quiere realizar el usuario?') {
                         if (userLower.includes('seguimiento') && elements[flow.target]?.name === 'Seguimiento') {
                             nextFlow = flow;
                             break;
                         }
                         if (userLower.includes('envio') && elements[flow.target]?.name === 'Envío') {
                             nextFlow = flow;
                             break;
                         }
                         if (userLower.includes('consulta') && elements[flow.target]?.name === 'Consulta') {
                             nextFlow = flow;
                             break;
                         }
                    }
                    // For "Solicitud Documentación del usuario?", map "sí" or "no" to correct destinations
                    if (currentElement.name === 'Solicitud Documentación del usuario') {
                        if ((userLower.includes('sí') || userLower.includes('si')) && elements[flow.target]?.name === 'Verificación de la documentación (¿Documentación completa?)') {
                            nextFlow = flow;
                            break;
                        }
                        if (userLower.includes('no') && elements[flow.target]?.name === 'Envío cancelado') {
                            nextFlow = flow;
                            break;
                        }
                    }

                    // Specific handling for the gateway "Verificación de la documentación (¿Documentación completa?)"
                    // If the user says 'no', it should return to 'Solicitud Documentación del usuario'
                    if (currentElement.name === 'Verificación de la documentación (¿Documentación completa?)') {
                        if (userLower.includes('no')) {
                             addMessage('bot', "Documentación incompleta. Por favor, vuelva a enviar los documentos requeridos.");
                             // This 'Id_c72c6ce3-757a-4b93-a055-4cc2f27e1caf' is still a hardcoded ID
                             // For full dynamism, you'd need a more generic way to identify "go back" paths
                             // e.g., by looking at incoming flows from a previous task or a loop.
                             currentElement = elements['Id_c72c6ce3-757a-4b93-a055-4cc2f27e1caf']; // Return to the request task
                             userInput.disabled = false;
                             sendButton.disabled = false;
                             return; // Wait for new input
                        }
                    }
                }


                if (nextFlow) {
                    currentElement = elements[nextFlow.target];
                    await proceedChat(); // Proceed based on user's choice
                } else {
                    let possibleChoices = [];
                    if (currentElement.type === 'exclusiveGateway' || 
                        currentElement.name === 'Verificación de la documentación (¿Documentación completa?)' ||
                        currentElement.name === '¿Se aprueba el envío?' ||
                        currentElement.name === '¿Estado del envío completado?' ||
                        currentElement.name === 'Confirmación de identidad') {
                        possibleChoices = currentElement.outgoing.map(flow => flow.name.toLowerCase()).filter(name => name);
                        if (possibleChoices.length === 0) possibleChoices = ['sí', 'no']; // Generic fallback
                    } else if (currentElement.name === 'Qué quiere realizar el usuario?') {
                         possibleChoices = ['seguimiento', 'envio', 'consulta'];
                    } else if (currentElement.name === 'Solicitud Documentación del usuario') {
                        possibleChoices = ['sí', 'no'];
                    }

                    addMessage('bot', `No entendí su elección. Por favor, responda con una de las siguientes opciones: ${possibleChoices.join(', ')}.`);
                    userInput.disabled = false; // Enable input again
                    sendButton.disabled = false;
                }
            } else if (currentElement.name === 'Solicitud número de seguimiento' ||
                       currentElement.name === 'Consulta' ||
                       currentElement.name === 'Decisión administrativa' ||
                       currentElement.name === 'Generación de número de seguimiento' ||
                       currentElement.name === 'Realizar envío' ||
                       currentElement.name === 'Seguimiento' ||
                       currentElement.name === 'Envío' ||
                       currentElement.name === 'Validación de identidad' ||
                       currentElement.name === 'Consulta sobre el envío asociado' ||
                       currentElement.name === 'Base de datos (búsqueda de la encomienda)'
                       ) {
                // For tasks that expect arbitrary text input (like tracking number or general inquiry)
                addMessage('bot', `Recibido: "${userText}". Procesando...`);
                // Assume a direct progression after receiving input for these tasks
                const nextFlow = currentElement.outgoing[0];
                if (nextFlow) {
                    currentElement = elements[nextFlow.target];
                    await proceedChat();
                } else {
                    addMessage('bot', `Ocurrió un error inesperado. Por favor, intente de nuevo.`);
                    endChat();
                }
            } else {
                addMessage('bot', `Lo siento, no puedo procesar esa entrada en esta etapa. Por favor, reinicie el chat.`);
                endChat();
            }
        }

        // Cargar el diagrama BPMN cuando se hace clic en el botón
        loadBpmnBtn.addEventListener('click', async () => {
            const xml = bpmnXmlInput.value;
            if (!xml) {
                customAlert('Error', 'Por favor, pegue el XML de BPMN en el área de texto primero.');
                return;
            }

            try {
                await viewer.importXML(xml);
                viewer.get('canvas').zoom('fit-viewport');
                customAlert('Éxito', '¡Diagrama BPMN cargado correctamente!');

                // Analizar BPMN para la lógica del chatbot
                const parsedResult = await parseBPMN(xml);
                if (parsedResult) {
                    bpmnProcess = parsedResult.process;
                    elements = parsedResult.elements;
                    // Optionally, you can find and highlight the start event after loading
                    const startEvent = Object.values(elements).find(el => el.type === 'startEvent');
                    if (startEvent) {
                        currentElement = startEvent; // Set the initial current element for the visualizer
                        highlightElement(currentElement.id);
                    }
                } else {
                    bpmnProcess = null;
                    elements = {};
                    currentElement = null;
                }
            } catch (err) {
                customAlert('Error', `No se pudo importar el diagrama BPMN: ${err.message}`);
                bpmnProcess = null;
                elements = {};
                currentElement = null;
            }
        });

        // Manejador del botón Iniciar Chat
        startChatButton.addEventListener('click', async () => {
            chatMessagesDiv.innerHTML = ''; // Clear previous chat
            isChatActive = true;
            startChatButton.disabled = true;
            userInput.disabled = true; // Disable until bot requests it
            sendButton.disabled = true;

            if (!bpmnProcess || Object.keys(elements).length === 0) {
                customAlert('Error', 'Por favor, cargue un diagrama BPMN primero haciendo clic en "Cargar Diagrama BPMN".');
                endChat();
                return;
            }

            // Find the start event to begin the chat
            const startEvent = Object.values(elements).find(el => el.type === 'startEvent');
            if (startEvent) {
                currentElement = startEvent;
                await proceedChat();
            } else {
                customAlert('Error', 'No se encontró ningún evento de inicio en el diagrama BPMN cargado. No se puede iniciar el chat.');
                endChat();
            }
        });

        // Manejador del botón Enviar y la tecla Enter
        sendButton.addEventListener('click', handleUserInput);
        userInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !userInput.disabled) {
                handleUserInput();
            }
        });

        // Finalizar el chat de forma elegante
        function endChat() {
            isChatActive = false;
            userInput.disabled = true;
            sendButton.disabled = true;
            startChatButton.disabled = false;
            currentElement = null;
            // Clear highlighting when chat ends
            if (lastHighlightedElementId) {
                viewer.get('canvas').removeMarker(lastHighlightedElementId, 'highlight');
                lastHighlightedElementId = null;
            }
            addMessage('bot', "Sesión de chat finalizada. Haga clic en 'Iniciar Chat' para comenzar una nueva conversación.");
        }

        // Automatically load default BPMN diagram on page load if uncommented
        // document.addEventListener('DOMContentLoaded', () => {
        //     loadBpmnBtn.click();
        // });
    </script>
</body>

</html>